name: PR Sanity Review

on: [pull_request]

jobs:
  label-pull-request-with-size:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Calculate PR size and label
        run: |
          #!/bin/bash
          # Patterns to ignore
          IGNORE_PATTERNS=("*.lock" "*.csv" "*.yaml" "*.txt")

          # Function to check if a file matches any ignored patterns
          matches_ignore_pattern() {
            for pattern in "${IGNORE_PATTERNS[@]}"; do
              if [[ $1 == $pattern ]]; then
                return 0
              fi
            done
            return 1
          }

          # Initialize line count
          total_lines=0

          # List all files in PR and calculate size for non-ignored ones
          for file in $(git diff --name-only ${{ github.event.before }} ${{ github.event.after }}); do
            if ! matches_ignore_pattern "$file"; then
              if [ -f "$file" ]; then
                lines=$(wc -l < "$file")
                total_lines=$((total_lines + lines))
              fi
            fi
          done

          echo "Total lines in PR (excluding ignored patterns): $total_lines"

          # Determine the size label based on total lines
          SIZE_LABEL="feat XS"
          if [ "$total_lines" -le 100 ]; then
            SIZE_LABEL="feat XS"
          elif [ "$total_lines" -le 300 ]; then
            SIZE_LABEL="feat S"
          elif [ "$total_lines" -le 900 ]; then
            SIZE_LABEL="feat M"
          elif [ "$total_lines" -le 1800 ]; then
            SIZE_LABEL="feat L"
          else
            SIZE_LABEL="feat XL"
          fi

          # Output the size label to an environment file
          echo "Setting PR size label to: $SIZE_LABEL"
          echo "SIZE_LABEL=$SIZE_LABEL" >> $GITHUB_ENV
      - name: Add size label to PR
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const sizeLabel = process.env.SIZE_LABEL;
            const prNumber = context.payload.pull_request.number;
            const repoName = context.repo.repo;
            const owner = context.repo.owner;
            // Add the label to the PR
            await github.rest.issues.addLabels({
              owner: owner,
              repo: repoName,
              issue_number: prNumber,
              labels: [sizeLabel]
            });
        env:
          SIZE_LABEL: ${{ env.SIZE_LABEL }}

  sanity-checks:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout base branch
        uses: actions/checkout@v3
        with:
          ref: ${{ github.base_ref }} # This fetches the latest commit from the target branch
          fetch-depth: 2 # Fetches 2 commits to ensure we have the commit for merge-base calculation

      - name: Get merge base SHA
        id: get-merge-base
        run: |
          echo "MERGE_BASE_SHA=$(git merge-base HEAD ${{ github.event.pull_request.base.sha }})" >> $GITHUB_ENV

      - name: Checkout PR code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.sha }} # This fetches the PR's latest commit
          fetch-depth: 0 # Fetches all history for the PR branch only

      - name: Check Line Endings
        run: |
          #!/bin/bash
          # Flag to track line ending issues
          line_ending_issue_found=0

          # Get the SHA for the merge base from the environment variable set in the previous step
          merge_base_sha=${{ steps.get-merge-base.outputs.MERGE_BASE_SHA }}

          # Check that merge_base_sha is not empty
          if [ -z "$merge_base_sha" ]; then
            echo "MERGE_BASE_SHA is not set. Exiting."
            exit 1
          fi

          # List all files modified in the PR, excluding deleted files
          files=$(git diff --name-only --diff-filter=d $merge_base_sha ${{ github.sha }})

          # Check each file for CRLF line endings
          for file in $files; do
            # Check if the file contains CRLF line endings
            if grep -qP "\r\n" "$file"; then
              # CRLF line endings detected
              echo "::error file=$file::File $file has CRLF line endings."
              line_ending_issue_found=1
            fi
          done

          # If any file has CRLF line endings, fail the check
          if [ "$line_ending_issue_found" -ne 0 ]; then
            echo "One or more files have CRLF line endings."
            exit 1
          else
            echo "All checked files have LF line endings."
          fi
